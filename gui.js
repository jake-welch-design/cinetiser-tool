import {
  getDefaultParameters,
  GUI_CONFIG,
  clampParameter,
} from "./modules/config.js";

/**
 * GUI Controller - handles all GUI interactions
 */
class GUIController {
  constructor() {
    this.imageFile = null;
    this.parameters = getDefaultParameters();
    
    // Global parameters that apply to all cuts
    this.globalParameterKeys = ['imagePosX', 'imagePosY', 'imageZoom', 'canvasWidth', 'canvasHeight'];
    this.globalParameters = {}; // Will be initialized in initializeControls

    // Reference to sketch instance (set by sketch.js)
    this.sketch = null;

    // Flag to prevent event listeners from firing during programmatic updates
    this.isUpdatingControls = false;

    this.initializeControls();
    this.setupEventListeners();
  }

  initializeControls() {
    // File input elements
    this.imageInput = document.getElementById("imageInput");

    // Clear file input on page load
    if (this.imageInput) {
      this.imageInput.value = "";
    }

    // Parameter controls - dynamically created from config.js
    this.controls = {};
    console.log(
      "Looking for controls from GUI_CONFIG:",
      Object.keys(GUI_CONFIG)
    );

    Object.keys(GUI_CONFIG).forEach((paramKey) => {
      const slider = document.getElementById(paramKey);
      const input = document.getElementById(paramKey + "Value");
      const select = document.querySelector(`select#${paramKey}`);

      const config = GUI_CONFIG[paramKey] || {};

      console.log(`Searching for ${paramKey}:`, {
        sliderFound: !!slider,
        inputFound: !!input,
        selectFound: !!select,
      });

      if (select) {
        // Select/dropdown control
        this.controls[paramKey] = { select };
        console.log(`✓ Select control registered for: ${paramKey}`);
      } else if (slider) {
        if (config.type === "boolean") {
          // checkbox/switch
          this.controls[paramKey] = { slider };
          console.log(`✓ Checkbox control registered for: ${paramKey}`);
        } else {
          // Only use number input if it already exists in DOM (canvas width/height only)
          // Do NOT create inputs dynamically - they should be generated by gui-generator.js
          this.controls[paramKey] = {
            slider,
            input: input || null,
          };
          console.log(`✓ Control registered for: ${paramKey}`);
        }
      } else {
        console.warn(`✗ Control not found for parameter: ${paramKey}`);
      }
    });

    console.log("Final controls object:", this.controls);

    // Cuts selector grid
    this.cutsGrid = document.getElementById("cuts-grid");
    this.cutButtons = [];
    this.currentCutIndex = 0; // Default to Cut 1 (index 0)
    
    // Separate global parameters from per-cut parameters
    this.globalParameters = {};
    this.globalParameterKeys.forEach(key => {
      this.globalParameters[key] = this.parameters[key];
    });
    
    this.cutParametersMap = {}; // Store parameters for each cut: {cutIndex: {paramKey: value, ...}}

    this.initializeCutsGrid();

    // Buttons
    this.saveBtn = document.getElementById("saveBtn");
    this.resetBtn = document.getElementById("resetBtn");

    this.guiToggleBtn = document.getElementById("gui-toggle");
    this.guiCloseBtn = document.getElementById("gui-close");
    this.guiPanel = document.getElementById("gui-panel");

    // GUI toggle state (defaults to open)
    this.isGuiOpen = true;
    if (this.guiPanel) {
      this.guiPanel.classList.remove("hidden");
    }
    document.body.classList.remove("gui-hidden");
    if (this.guiToggleBtn) {
      this.guiToggleBtn.style.display = "none";
    }
  }

  setupEventListeners() {
    // File input handler
    if (this.imageInput) {
      this.imageInput.addEventListener("change", (e) =>
        this.handleImageUpload(e)
      );
    }

    // Parameter control handlers
    Object.keys(this.controls).forEach((param) => {
      const control = this.controls[param];

      // Select/dropdown control
      if (control.select) {
        control.select.addEventListener("change", (e) => {
          if (this.isUpdatingControls) return; // Skip if programmatically set
          const value = e.target.value;
          this.parameters[param] = value;
          this.onParameterChange(param, value);
        });
      } else if (control.slider && control.input) {
        // Sync slider and number input with validation
        control.slider.addEventListener("input", (e) => {
          if (this.isUpdatingControls) return; // Skip if programmatically set
          const sliderMin = parseFloat(control.slider.min);
          const sliderMax = parseFloat(control.slider.max);
          const value = clampParameter(
            param,
            e.target.value,
            sliderMin,
            sliderMax
          );
          this.parameters[param] = value;
          control.input.value = value;
          this.onParameterChange(param, value);
        });

        control.input.addEventListener("input", (e) => {
          if (this.isUpdatingControls) return; // Skip if programmatically set
          const sliderMin = parseFloat(control.slider.min);
          const sliderMax = parseFloat(control.slider.max);
          const value = clampParameter(
            param,
            e.target.value,
            sliderMin,
            sliderMax
          );
          this.parameters[param] = value;
          control.slider.value = value;
          this.onParameterChange(param, value);
        });
      } else if (control.slider && !control.input) {
        // slider only (effect parameters) or checkbox / boolean control
        if (GUI_CONFIG[param]?.type === "boolean") {
          // checkbox / boolean control
          control.slider.addEventListener("change", (e) => {
            if (this.isUpdatingControls) return; // Skip if programmatically set
            const checked = e.target.checked;
            this.parameters[param] = checked;
            this.onParameterChange(param, checked);

            // If this is the animated toggle, enable/disable rotationSpeed control
            if (param === "animated") {
              this.toggleRotationSpeed(checked);
            }
          });
        } else {
          // slider only (effect parameters)
          control.slider.addEventListener("input", (e) => {
            if (this.isUpdatingControls) return; // Skip if programmatically set
            const sliderMin = parseFloat(control.slider.min);
            const sliderMax = parseFloat(control.slider.max);
            const value = clampParameter(
              param,
              e.target.value,
              sliderMin,
              sliderMax
            );
            this.parameters[param] = value;
            this.onParameterChange(param, value);
          });
        }
      }
    });

    // Canvas preset buttons
    const presetButtons = document.querySelectorAll(".canvas-preset-btn");
    presetButtons.forEach((button) => {
      button.addEventListener("click", () => {
        const width = parseInt(button.getAttribute("data-width"));
        const height = parseInt(button.getAttribute("data-height"));
        this.applyCanvasPreset(width, height);
      });
    });

    // Button handlers
    if (this.saveBtn) {
      this.saveBtn.addEventListener("click", () => this.saveImage());
    }
    if (this.resetBtn) {
      this.resetBtn.addEventListener("click", () => this.resetImage());
    }
    if (this.guiToggleBtn) {
      this.guiToggleBtn.addEventListener("click", () => this.openGui());
    }
    if (this.guiCloseBtn) {
      this.guiCloseBtn.addEventListener("click", () => {
        this.closeGui();
      });
    }

    // ESC key to close GUI
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.isGuiOpen) {
        this.closeGui();
      }
    });
  }

  initializeCutsGrid() {
    // Create 6 cut selector buttons (3 rows of 2)
    if (!this.cutsGrid) return;

    this.cutsGrid.innerHTML = "";
    this.cutButtons = [];

    for (let i = 0; i < 6; i++) {
      const button = document.createElement("button");
      button.className = "cut-selector-btn";
      if (i === 0) {
        button.classList.add("active"); // Cut 1 is active by default
      }
      button.textContent = `Cut ${i + 1}`;
      button.dataset.cutIndex = i;

      button.addEventListener("click", () => this.selectCut(i));

      this.cutsGrid.appendChild(button);
      this.cutButtons.push(button);
    }

    // Initialize cut parameters map - each cut gets its OWN independent copy
    // But ONLY for per-cut parameters (not global ones like image position/zoom)
    for (let i = 0; i < 6; i++) {
      // Create object with only per-cut parameters
      this.cutParametersMap[i] = {};
      Object.keys(this.parameters).forEach(key => {
        if (!this.globalParameterKeys.includes(key)) {
          // Only copy non-global parameters
          this.cutParametersMap[i][key] = this.parameters[key];
        }
      });
    }
    console.log("✅ Cut parameters map initialized with per-cut parameters only");
    console.log("✅ Global parameters:", this.globalParameterKeys);
  }

  selectCut(cutIndex) {
    console.log(`\n${"=".repeat(60)}`);
    console.log(`>>> SELECTING CUT ${cutIndex}`);
    console.log(`${"=".repeat(60)}`);

    // Step 1: Update active button
    this.cutButtons.forEach((btn, idx) => {
      btn.classList.toggle("active", idx === cutIndex);
    });

    // Step 2: Switch to the selected cut
    this.currentCutIndex = cutIndex;
    
    // Step 3: Rebuild this.parameters by combining global + per-cut parameters
    this.parameters = {
      ...this.globalParameters,
      ...this.cutParametersMap[cutIndex]
    };

    console.log(`Switched to Cut ${cutIndex}`);
    console.log(`  Cut-specific: cutSize = ${this.parameters.cutSize}`);
    console.log(`  Global: imagePosX = ${this.parameters.imagePosX}, imagePosY = ${this.parameters.imagePosY}`);

    // Step 4: Notify sketch to clear caches BEFORE updating GUI
    // This ensures caches are cleared before any slider events fire
    if (this.sketch && this.sketch.selectCutSlot) {
      this.sketch.selectCutSlot(cutIndex);
    }

    // Step 5: Update GUI controls (after caches are cleared)
    this.updateControlsFromParameters();

    console.log(`${"=".repeat(60)}\n`);
  }

  /**
   * Get parameters for a specific cut slot (used by sketch for rendering each cut)
   * Combines per-cut parameters with global parameters
   */
  getParametersForSlot(slotIndex) {
    if (slotIndex < 0 || slotIndex >= 6) {
      console.warn(`Invalid slot index: ${slotIndex}`);
      return this.getDefaultParameters();
    }
    
    // Combine per-cut parameters with current global parameters
    return {
      ...this.globalParameters,
      ...this.cutParametersMap[slotIndex]
    };
  }

  updateControlsFromParameters() {
    // Set flag so event listeners know this is a programmatic update
    this.isUpdatingControls = true;

    // Update all control values to match current parameters
    Object.keys(this.controls).forEach((paramKey) => {
      const value = this.parameters[paramKey];
      const control = this.controls[paramKey];

      if (control.slider) {
        control.slider.value = value;
        if (control.slider.type === "checkbox") {
          control.slider.checked = value;
        }
      }
      if (control.input) {
        control.input.value = value;
      }
      if (control.select) {
        control.select.value = value;
      }
    });

    // Clear flag
    this.isUpdatingControls = false;
  }

  updateCutButtonStates() {
    // Update which buttons show as "has-cut" based on sketch's cuts array
    if (!this.sketch || !this.sketch.getCutIndices) return;

    const cutIndices = this.sketch.getCutIndices();
    this.cutButtons.forEach((btn, idx) => {
      if (cutIndices.includes(idx)) {
        btn.classList.add("has-cut");
      } else {
        btn.classList.remove("has-cut");
      }
    });
  }

  applyCanvasPreset(width, height) {
    // Update parameter values
    this.parameters.canvasWidth = width;
    this.parameters.canvasHeight = height;

    // Update UI controls
    if (this.controls.canvasWidth) {
      this.controls.canvasWidth.slider.value = width;
      this.controls.canvasWidth.input.value = width;
    }
    if (this.controls.canvasHeight) {
      this.controls.canvasHeight.slider.value = height;
      this.controls.canvasHeight.input.value = height;
    }

    // Notify sketch
    this.onParameterChange("canvasWidth", width);
    this.onParameterChange("canvasHeight", height);
  }

  handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    this.imageFile = file;
    const reader = new FileReader();

    reader.onload = (e) => {
      // Notify sketch if connected
      if (this.sketch && this.sketch.onImageLoaded) {
        this.sketch.onImageLoaded(e.target.result);
      }
    };

    reader.readAsDataURL(file);
  }

  onParameterChange(paramName, value) {
    if (this.isUpdatingControls) {
      return;
    }

    // Update the appropriate storage location
    if (this.globalParameterKeys.includes(paramName)) {
      // Global parameter - update global storage
      this.globalParameters[paramName] = value;
      this.parameters[paramName] = value; // Also update combined view
    } else {
      // Per-cut parameter - update current cut's storage
      this.cutParametersMap[this.currentCutIndex][paramName] = value;
      this.parameters[paramName] = value; // Also update combined view
    }

    // Notify sketch
    if (this.sketch && this.sketch.onParameterChange) {
      this.sketch.onParameterChange(paramName, value, this.parameters);
    }
  }

  saveImage() {
    // Call sketch's save function if available
    if (this.sketch && this.sketch.saveCanvas) {
      this.sketch.saveCanvas();
    } else {
      console.warn("No save function available");
    }
  }

  resetImage() {
    // Call sketch's reset function if available
    if (this.sketch && this.sketch.resetImage) {
      this.sketch.resetImage();
    } else {
      console.warn("No reset function available");
    }
  }

  openGui() {
    this.isGuiOpen = true;
    const guiSection = document.getElementById("gui-section");
    if (guiSection) {
      guiSection.classList.remove("hidden");
    }
    if (this.guiPanel) {
      this.guiPanel.classList.remove("hidden");
    }
    if (this.guiToggleBtn) {
      this.guiToggleBtn.style.display = "none";
    }
  }

  closeGui() {
    this.isGuiOpen = false;
    const guiSection = document.getElementById("gui-section");
    if (guiSection) {
      guiSection.classList.add("hidden");
    }
    if (this.guiPanel) {
      this.guiPanel.classList.add("hidden");
    }
    if (this.guiToggleBtn) {
      this.guiToggleBtn.style.display = "inline-block";
    }
  }

  // Update slider bounds dynamically (e.g., when image loads)
  updateSliderBounds(paramKey, min, max) {
    const control = this.controls[paramKey];
    if (!control || !control.slider) {
      console.warn(`Cannot update bounds for ${paramKey}: control not found`);
      return;
    }

    // Update slider min/max
    control.slider.min = min;
    control.slider.max = max;

    // Only update numeric input if it already exists (for canvasWidth and canvasHeight only)
    if (control.input) {
      control.input.min = min;
      control.input.max = max;
    }

    // Check if movement is possible (min != max)
    const canMove = Math.abs(max - min) > 0.01; // Use small epsilon for floating point comparison

    if (canMove) {
      control.slider.disabled = false;
      control.slider.style.opacity = "1";
      control.slider.style.cursor = "pointer";

      if (control.input) {
        control.input.disabled = false;
        control.input.style.opacity = "1";
      }
    } else {
      control.slider.disabled = true;
      control.slider.style.opacity = "0.4";
      control.slider.style.cursor = "not-allowed";

      if (control.input) {
        control.input.disabled = true;
        control.input.style.opacity = "0.4";
      }
    }

    // Clamp current value to new bounds
    const currentValue = this.parameters[paramKey];
    const clampedValue = Math.max(min, Math.min(max, currentValue));

    if (currentValue !== clampedValue) {
      this.updateParameterValue(paramKey, clampedValue);
    }

    console.log(
      `Updated bounds for ${paramKey}: [${min}, ${max}], canMove: ${canMove}`
    );
  }

  // Update a parameter value programmatically
  updateParameterValue(paramKey, value) {
    const control = this.controls[paramKey];
    if (!control || !control.slider) {
      console.warn(`Cannot update value for ${paramKey}: control not found`);
      return;
    }

    this.parameters[paramKey] = value;

    // If numeric control with input
    if (control.input) {
      control.slider.value = value;
      control.input.value = value;
    } else {
      // boolean checkbox
      control.slider.checked = !!value;
    }

    // Notify sketch
    this.onParameterChange(paramKey, value);
  }

  // Enable/disable (gray out) the rotationSpeed control based on animated toggle
  toggleRotationSpeed(enabled) {
    const control = this.controls["rotationSpeed"];
    if (!control || !control.slider) return;

    if (control.input) {
      if (enabled) {
        control.slider.disabled = false;
        control.input.disabled = false;
        control.slider.style.opacity = "1";
        control.input.style.opacity = "1";
      } else {
        control.slider.disabled = true;
        control.input.disabled = true;
        control.slider.style.opacity = "0.4";
        control.input.style.opacity = "0.4";
      }
    }
  }

  // Method to connect the sketch instance
  connectSketch(sketch) {
    this.sketch = sketch;
  }

  /**
   * DEBUG: Get per-cut parameter state for diagnostics
   * @returns {object} - Complete per-cut parameter information
   */
  getPerCutParameterState() {
    console.log("=== PER-CUT PARAMETER STATE ===");
    console.log("Current Cut Index:", this.currentCutIndex);
    console.log("Current Parameters:", { ...this.parameters });
    console.log("\nAll Cut Parameters:");
    for (let i = 0; i < 6; i++) {
      console.log(`  Slot ${i}:`, { ...this.cutParametersMap[i] });
    }
    console.log("================================\n");
    return {
      currentCutIndex: this.currentCutIndex,
      currentParameters: { ...this.parameters },
      allCutParameters: Object.fromEntries(
        Array.from({ length: 6 }, (_, i) => [
          i,
          { ...this.cutParametersMap[i] },
        ])
      ),
    };
  }

  /**
   * DEBUG: Verify a specific parameter is different between cuts
   */
  verifyParameterIndependence(paramName) {
    const values = Array.from({ length: 6 }, (_, i) => ({
      slot: i,
      value: this.cutParametersMap[i]?.[paramName],
    }));
    console.log(`Parameter "${paramName}" values across cuts:`, values);
    return values;
  }
}

// Create global GUI instance when DOM is ready
let gui = null;

// Initialize GUI after DOM and controls are ready
function initGUI() {
  console.log("Initializing GUI Controller...");
  gui = new GUIController();
  window.gui = gui; // Make available globally
  console.log("GUI Controller initialized");
  console.log("Available controls:", Object.keys(gui.controls));
  // Ensure rotationSpeed control state reflects the default animated parameter
  try {
    const defaults = getDefaultParameters();
    if (defaults && typeof defaults.animated !== "undefined") {
      gui.toggleRotationSpeed(!!defaults.animated);
    }
  } catch (e) {
    console.warn("Could not initialize animated toggle state:", e);
  }
}

// Wait for the gui-generator to dispatch the 'guiControlsGenerated' event
window.addEventListener("guiControlsGenerated", () => {
  console.log("GUI controls generated event received");
  initGUI();
});

// Fallback: if event was already dispatched or gui-generator loads in different order
setTimeout(() => {
  if (!gui) {
    console.log("Initializing GUI via fallback timeout");
    initGUI();
  }
}, 500);

// Export proxy that ensures GUI is ready
export default new Proxy(
  {},
  {
    get(target, prop) {
      if (prop === "connectSketch") {
        return (sketch) => {
          if (gui) {
            gui.connectSketch(sketch);
          } else {
            // If GUI not ready yet, wait for it
            const checkGui = setInterval(() => {
              if (gui) {
                gui.connectSketch(sketch);
                clearInterval(checkGui);
              }
            }, 50);
          }
        };
      }
      // For any other property, try to access it from gui
      if (gui && prop in gui) {
        const value = gui[prop];
        return typeof value === "function" ? value.bind(gui) : value;
      }
      return undefined;
    },
  }
);
